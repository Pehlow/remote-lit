"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
//@ts-ignore
var addon = __importStar(require("../native"));
var Bot = /** @class */ (function () {
    function Bot() {
        /**
         * Containes keys to be used in key presses.
         */
        var _this = this;
        /**
         * Contains all the mouse functions.
         */
        this.mouse = {
            /**
             * @param {number} x The x coordinate of the mouse.
             * @param {number} y The y coordinate of the mouse.
             * @returns {boolean}
             * Move the mouse to the given coordinates immediatly.
             */
            move: function (x, y) {
                return new Promise(function (resolve, reject) {
                    addon.mouseMove(x, y, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {number} startx The beginning x coordinate of the mouse.
             * @param {number} starty The beginning y coordinate of the mouse.
             * @param {number} endx The ending x coordinate of the mouse.
             * @param {number} endy The ending y coordinate of the mouse.
             * @param {number} [delay=1] The delay of each pixel movement of the mouse in ms.
             * Move the mouse to the given coordinates smoothly.
             */
            moveSmooth: function (startx, starty, endx, endy, delay) {
                if (delay === void 0) { delay = 1; }
                return new Promise(function (resolve, reject) {
                    addon.mouseMoveSmooth(startx, starty, endx, endy, delay, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {"left" | "right"} button Perform a left or right button click.
             * Click the mouse in the given direction.
             */
            click: function (button) {
                return new Promise(function (resolve, reject) {
                    addon.mouseClick(button, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {"left" | "right"} direction Perform a scroll horizontal (x) or vertical (y).
             * @param {number} amount The amount of the scroll.
             */
            scroll: function (direction, amount) {
                return new Promise(function (resolve, reject) {
                    addon.mouseScroll(direction, amount, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
        };
        /**
         * Contains all of the keyboard functions.
         */
        this.keyboard = {
            /**
             * @param {string} str The string to write.
             * Write the given string to the keyboard without delay.
             */
            write: function (str) {
                return new Promise(function (resolve, reject) {
                    addon.keyWrite(str, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {string} str The string to write smoothly.
             * @param {number} [delay=100] The delay of each key press in ms.
             * Write the given string to the keyboard smoothly.
             */
            writeSmooth: function (str, delay) {
                if (delay === void 0) { delay = 200; }
                return new Promise(function (resolve, reject) {
                    addon.keyWriteSmooth(str, delay, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {"alt" | "shift" | "backspace" | "capslock" | "space" | "escape" | "tab" | "f4" | "f5" | "rightarrow" | "leftarrow" | "uparrow" | "downarrow" | "esc" | "return"} key The lowercase string of the key desired to be hold pressed.
             * Hold a key pressed. Stop the key from being press using the keyUp function.
             */
            keyDown: function (key) {
                return new Promise(function (resolve, reject) {
                    addon.keyDown(key, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {"alt" | "shift" | "backspace" | "capslock" | "space" | "escape" | "tab" | "f4" | "f5" | "rightarrow" | "leftarrow" | "uparrow" | "downarrow" | "esc" | "return"} key The lowercase string of the key desired to be hold released.
             * Release a pressed key.
             */
            keyUp: function (key) {
                return new Promise(function (resolve, reject) {
                    addon.keyUp(key, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {"alt" | "shift" | "backspace" | "capslock" | "space" | "escape" | "tab" | "f4" | "f5" | "rightarrow" | "leftarrow" | "uparrow" | "downarrow" | "esc" | "return"} key The lowercase string of the key desired to be hold pressed once.
             * Press a key once.
             */
            keyClick: function (key) {
                return new Promise(function (resolve, reject) {
                    addon.keyClick(key, function (err, res) {
                        if (err)
                            return reject(err);
                        resolve(res);
                    });
                });
            },
            /**
             * @param {"alt" | "shift" | "backspace" | "capslock" | "space" | "escape" | "tab" | "f4" | "f5" | "rightarrow" | "leftarrow" | "uparrow" | "downarrow" | "esc" | "return"} key1 The lowercase string of the first key desired to be hold.
             * @param {"alt" | "shift" | "backspace" | "capslock" | "space" | "escape" | "tab" | "f4" | "f5" | "rightarrow" | "leftarrow" | "uparrow" | "downarrow" | "esc" | "return"} key2 The lowercase string of the second key desired to be pressed once.
             * @param {number} [delay=100] The delay of the second key press in ms. The delay might be required to higher for different machines.
             * Press key1, then press key2. Used for pressing keys simultaneously. The function holds down key1, then presses key2 once, and then releases key1.
             */
            keyChain: function (key1, key2, delay) {
                if (delay === void 0) { delay = 200; }
                return __awaiter(_this, void 0, void 0, function () {
                    var _this = this;
                    return __generator(this, function (_a) {
                        return [2 /*return*/, new Promise(function (resolve, reject) { return __awaiter(_this, void 0, void 0, function () {
                                var bot_1, e_1;
                                var _this = this;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            _a.trys.push([0, 2, , 3]);
                                            bot_1 = new Bot();
                                            return [4 /*yield*/, bot_1.keyboard.keyDown(key1)];
                                        case 1:
                                            _a.sent();
                                            setTimeout(function () { return __awaiter(_this, void 0, void 0, function () {
                                                return __generator(this, function (_a) {
                                                    switch (_a.label) {
                                                        case 0: return [4 /*yield*/, bot_1.keyboard.keyClick(key2)];
                                                        case 1:
                                                            _a.sent();
                                                            return [4 /*yield*/, bot_1.keyboard.keyUp(key1)];
                                                        case 2:
                                                            _a.sent();
                                                            resolve(true);
                                                            return [2 /*return*/];
                                                    }
                                                });
                                            }); }, delay);
                                            return [3 /*break*/, 3];
                                        case 2:
                                            e_1 = _a.sent();
                                            reject(e_1);
                                            return [3 /*break*/, 3];
                                        case 3: return [2 /*return*/];
                                    }
                                });
                            }); })];
                    });
                });
            },
        };
        /**
         * Contains a useful set of key shortcuts.
         */
        this.shortcuts = {
            /**
             * @param {number} [delay = 200] The delay of the tab key being pressed
             * Perform ALT+TAB by pressing the tab button after the delay has occurred. The delay is required since the buttons are not pressed instantaneously. The delay might be required to higher for different machines.
             */
            altTab: function (delay) {
                if (delay === void 0) { delay = 200; }
                return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.keyboard.keyChain(Bot.keys.ALT, Bot.keys.TAB, delay)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                }); });
            },
            /**
             * @param {number} [delay = 200] The delay of the tab key being pressed
             * Perform Command/Windows+TAB by pressing the tab button after the delay has occurred. The delay is required since the buttons are not pressed instantaneously. The delay might be required to higher for different machines.
             */
            metaTab: function (delay) {
                if (delay === void 0) { delay = 200; }
                return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.keyboard.keyChain(Bot.keys.meta, Bot.keys.TAB, delay)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                }); });
            },
            /**
             * @param {number} [delay = 200] The delay of the f4 key being pressed
             * Perform ALT+F4 by pressing the f4 button after the delay has occurred. The delay is required since the buttons are not pressed instantaneously. The delay might be required to higher for different machines.
             */
            altF4: function (delay) {
                if (delay === void 0) { delay = 200; }
                return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.keyboard.keyChain(Bot.keys.ALT, Bot.keys.F4, delay)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                }); });
            },
            /**
             * @param {number} [delay = 200] The delay of the f5 key being pressed
             * Perform ALT+F5 by pressing the f5 button after the delay has occurred. The delay is required since the buttons are not pressed instantaneously. The delay might be required to higher for different machines.
             */
            altF5: function (delay) {
                if (delay === void 0) { delay = 200; }
                return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.keyboard.keyChain(Bot.keys.ALT, Bot.keys.F5, delay)];
                        case 1: return [2 /*return*/, _a.sent()];
                    }
                }); });
            },
        };
    }
    Bot.keys = {
        ALT: "alt",
        SHIFT: "shift",
        BACKSPACE: "backspace",
        CAPSLOCK: "capslock",
        SPACE: "space",
        ESCAPE: "escape",
        TAB: "tab",
        F4: "f4",
        F5: "f5",
        meta: "meta",
        ARROW: {
            RIGHT: "rightarrow",
            LEFT: "leftarrow",
            UP: "uparrow",
            DOWN: "downarrow as Key",
        },
        RETURN: "return",
        ENTER: "return",
    };
    return Bot;
}());
exports.Bot = Bot;
